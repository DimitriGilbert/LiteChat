// src/hooks/litechat/modules/AutoTitleControlModule.ts
// REVISED FILE 4 (Final Approach)
import React from "react";
import {
  ControlModule,
  LiteChatModApi,
  InteractionEvent,
  UiEvent,
  SettingsEvent,
} from "@/types/litechat/modding";
import { AutoTitleControlTrigger } from "@/components/LiteChat/prompt/control/auto-title/AutoTitleControlTrigger"; // Assume moved
import { useInteractionStore } from "@/store/interaction.store";
import { useSettingsStore } from "@/store/settings.store";

export class AutoTitleControlModule implements ControlModule {
  readonly id = "core-auto-title";
  private modApi: LiteChatModApi | null = null;
  private unregisterCallback: (() => void) | null = null;
  private eventUnsubscribers: (() => void)[] = [];

  // Transient state managed by the module instance
  private turnAutoTitleEnabled = false;

  // State derived from global stores/events
  private isStreaming = false;
  private isFirstInteraction = false;
  private globalAutoTitleEnabled = true;

  async initialize(modApi: LiteChatModApi): Promise<void> {
    this.modApi = modApi;
    this.turnAutoTitleEnabled = false;

    this.isStreaming = useInteractionStore.getState().status === "streaming";
    this.globalAutoTitleEnabled = useSettingsStore.getState().autoTitleEnabled;
    this.checkFirstInteraction();

    const unsubStatus = modApi.on(
      InteractionEvent.STATUS_CHANGED,
      (payload) => {
        this.isStreaming = payload.status === "streaming";
        // Component re-renders naturally if parent re-renders
      }
    );
    const unsubContext = modApi.on(UiEvent.CONTEXT_CHANGED, () => {
      this.checkFirstInteraction();
    });
    const unsubComplete = modApi.on(InteractionEvent.COMPLETED, () => {
      this.checkFirstInteraction();
    });
    const unsubSettings = modApi.on(
      SettingsEvent.AUTO_TITLE_ENABLED_CHANGED,
      (payload) => {
        this.globalAutoTitleEnabled = payload.enabled;
      }
    );

    this.eventUnsubscribers.push(
      unsubStatus,
      unsubContext,
      unsubComplete,
      unsubSettings
    );
    console.log(`[${this.id}] Initialized.`);
  }

  private checkFirstInteraction() {
    const interactionState = useInteractionStore.getState();
    const isFirst =
      interactionState.currentConversationId !== null &&
      interactionState.interactions.filter(
        (i) => i.conversationId === interactionState.currentConversationId
      ).length === 0;
    this.isFirstInteraction = isFirst;
    if (!isFirst && this.turnAutoTitleEnabled) {
      this.turnAutoTitleEnabled = false;
    }
  }

  // Getter for component to read state
  public getTurnEnabled = (): boolean => this.turnAutoTitleEnabled;
  public getIsStreaming = (): boolean => this.isStreaming;

  // Setter for component to update state
  public setTurnEnabled = (enabled: boolean) => {
    this.turnAutoTitleEnabled = enabled;
    // We might need a way to hint to React that a re-render is needed
    // if the component doesn't naturally re-render.
    // This is the tricky part without a direct notification mechanism.
    // For now, assume parent re-renders are sufficient or component uses local state.
  };

  register(modApi: LiteChatModApi): void {
    if (this.unregisterCallback) {
      console.warn(`[${this.id}] Already registered. Skipping.`);
      return;
    }

    // Define renderer within register scope to close over 'this'
    const triggerRenderer = () => {
      // Pass the module instance itself (or specific methods/getters)
      return React.createElement(AutoTitleControlTrigger, { module: this });
    };

    this.unregisterCallback = modApi.registerPromptControl({
      id: this.id,
      status: () => "ready",
      triggerRenderer: triggerRenderer,
      getMetadata: () => {
        return this.turnAutoTitleEnabled
          ? { autoTitleEnabledForTurn: true }
          : undefined;
      },
      clearOnSubmit: () => {
        this.turnAutoTitleEnabled = false;
      },
      show: () => this.globalAutoTitleEnabled && this.isFirstInteraction,
    });
    console.log(`[${this.id}] Registered.`);
  }

  destroy(): void {
    this.eventUnsubscribers.forEach((unsub) => unsub());
    this.eventUnsubscribers = [];
    if (this.unregisterCallback) {
      this.unregisterCallback();
      this.unregisterCallback = null;
    }
    this.modApi = null;
    console.log(`[${this.id}] Destroyed.`);
  }
}

// NOTE: AutoTitleControlTrigger needs refactoring:
/*
interface AutoTitleControlTriggerProps {
  module: AutoTitleControlModule; // Receive module instance
}

const AutoTitleControlTrigger: React.FC<AutoTitleControlTriggerProps> = ({ module }) => {
  // Use local state for UI feedback, synced with module state
  const [localEnabled, setLocalEnabled] = useState(module.getTurnEnabled());
  const isStreaming = module.getIsStreaming(); // Read current streaming state

  // Effect to sync local state if module state changes (requires re-render trigger)
  // This is the weak point - how to trigger re-render reliably?
  // Option 1: Rely on parent re-renders (unreliable)
  // Option 2: Component subscribes to a specific event emitted by the module (adds complexity back)
  // Option 3: Component uses a dummy state update triggered by the module (awkward)
  // Option 4: Component reads directly from module on every render (simplest if performance allows)

  // Let's try Option 4: Read directly on render
  const currentModuleEnabled = module.getTurnEnabled();
  const currentIsStreaming = module.getIsStreaming();

  const handleToggle = () => {
    const newState = !currentModuleEnabled;
    module.setTurnEnabled(newState);
    // Update local state immediately for responsiveness
    setLocalEnabled(newState);
  };

  // Sync local state if the underlying module state changes (detected on re-render)
  useEffect(() => {
     if (localEnabled !== currentModuleEnabled) {
         setLocalEnabled(currentModuleEnabled);
     }
  }, [currentModuleEnabled, localEnabled]);


  // Visibility is handled by the control's `show` method.

  return ( ... JSX using localEnabled and currentIsStreaming ... );
};
*/
